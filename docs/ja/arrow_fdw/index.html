<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="PG-Strom Development Team" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Apache Arrow - PG-Strom Manual</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="//fonts.googleapis.com/earlyaccess/notosansjp.css" rel="stylesheet" />
        <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" />
        <link href="../custom.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Apache Arrow";
        var mkdocs_page_input_path = "arrow_fdw.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> PG-Strom Manual
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
  [<strong>Japanese</strong> | <a href="../../arrow_fdw/"    style="color: #cccccc">English</a>]
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">はじめに</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../install/">インストール</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">利用ガイド</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../operations/">基本的な操作</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../brin/">BRINインデックス</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../partition/">パーティション</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../postgis/">GPU版PostGIS</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../gpusort/">GPUソート</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../troubles/">トラブルシューティング</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">先進機能</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../ssd2gpu/">GPUダイレクトSQL</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Apache Arrow</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_1">概要</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#apache-arrow_1">Apache Arrowとは</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">運用</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_3">外部テーブルの定義</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">外部テーブルオプション</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_5">外部テーブルに対するオプション</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_6">カラムに対するオプション</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_7">データ型の対応</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#explain">EXPLAIN出力の読み方</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#arrow_fdw">Arrow_Fdwの仮想列</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#arrow">Arrowファイルの作成方法</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#pyarrowpandas">PyArrow+Pandas</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pg2arrow">Pg2Arrow</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_8">先進的な使い方</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#ssdtogpusql">SSDtoGPUダイレクトSQL</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_9">パーティション設定</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../gpucache/">GPUキャッシュ</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../pinned_buffer/">Pinned Inner Buffer</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../fluentd/">Fluentd連携</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">リファレンス</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../ref_types/">データ型</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ref_devfuncs/">関数と演算子</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ref_sqlfuncs/">SQLオブジェクト</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ref_params/">GUCパラメータ</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">リリースノート</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../release_v6.0/">PG-Strom v6.0</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../release_v5.2/">PG-Strom v5.2</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../release_v5.1/">PG-Strom v5.1</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../release_v5.0/">PG-Strom v5.0</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../release_v3.0/">PG-Strom v3.0</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../release_v2.3/">PG-Strom v2.3</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../release_v2.2/">PG-Strom v2.2</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../release_v2.0/">PG-Strom v2.0</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">PG-Strom Manual</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">先進機能</li>
      <li class="breadcrumb-item active">Apache Arrow</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="apache-arrow">Apache Arrow (列指向データストア)</h1>
<h2 id="_1">概要</h2>
<p>PostgreSQLのテーブルは内部的に8KBのブロック<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>と呼ばれる単位で編成され、ブロックは全ての属性及びメタデータを含むタプルと呼ばれるデータ構造を行単位で格納します。行を構成するデータが近傍に存在するため、これはINSERTやUPDATEの多いワークロードに有効ですが、一方で大量データの集計・解析ワークロードには不向きであるとされています。</p>
<p>通常、大量データの集計においてはテーブル内の全ての列を参照する事は珍しく、多くの場合には一部の列だけを参照するといった処理になりがちです。この場合、実際には参照されない列のデータをストレージからロードするために消費されるI/Oの帯域は全く無駄ですが、行単位で編成されたデータに対して特定の列だけを取り出すという操作は困難です。</p>
<p>逆に列単位でデータを編成した場合、INSERTやUPDATEの多いワークロードに対しては極端に不利ですが、大量データの集計・解析を行う際には被参照列だけをストレージからロードする事が可能になるため、I/Oの帯域を最大限に活用する事が可能です。 またプロセッサの処理効率の観点からも、列単位に編成されたデータは単純な配列であるかのように見えるため、GPUにとってはCoalesced Memory Accessというメモリバスの性能を最大限に引き出すアクセスパターンとなる事が期待できます。</p>
<p><img alt="Row/Column data structure" src="../img/row_column_structure.png" /></p>
<h2 id="apache-arrow_1">Apache Arrowとは</h2>
<p>Apache Arrowとは、構造化データを列形式で記録、交換するためのデータフォーマットです。 主にビッグデータ処理のためのアプリケーションソフトウェアが対応しているほか、CやC++、Pythonなどプログラミング言語向けのライブラリが整備されているため、自作のアプリケーションからApache Arrow形式を扱うよう設計する事も容易です。</p>
<p><img alt="Row/Column data structure" src="../img/arrow_shared_memory.png" /></p>
<p>Apache Arrow形式ファイルの内部には、データ構造を定義するスキーマ（Schema）部分と、スキーマに基づいて列データを記録する1個以上のレコードバッチ（RecordBatch）部分が存在します。データ型としては、整数や文字列（可変長）、日付時刻型などに対応しており、個々の列データはこれらデータ型に応じた内部表現を持っています。</p>
<p>Apache Arrow形式におけるデータ表現は、必ずしも全ての場合でPostgreSQLのデータ表現と一致している訳ではありません。例えば、Arrow形式ではタイムスタンプ型のエポックは<code>1970-01-01</code>で複数の精度を持つ事ができますが、PostgreSQLのエポックは<code>2001-01-01</code>でマイクロ秒の精度を持ちます。</p>
<p>Arrow_Fdwは外部テーブルを用いてApache Arrow形式ファイルをPostgreSQL上で読み出す事を可能にします。例えば、列ごとに100万件の列データが存在するレコードバッチを8個内包するArrow形式ファイルをArrow_Fdwを用いてマップした場合、この外部テーブルを介してArrowファイル上の800万件のデータへアクセスする事ができるようになります。</p>
<h2 id="_2">運用</h2>
<h3 id="_3">外部テーブルの定義</h3>
<p>通常、外部テーブルを作成するには以下の3ステップが必要です。</p>
<ul>
<li><code>CREATE FOREIGN DATA WRAPPER</code>コマンドにより外部データラッパを定義する</li>
<li><code>CREATE SERVER</code>コマンドにより外部サーバを定義する</li>
<li><code>CREATE FOREIGN TABLE</code>コマンドにより外部テーブルを定義する</li>
</ul>
<p>このうち、最初の2ステップは<code>CREATE EXTENSION pg_strom</code>コマンドの実行に含まれており、個別に実行が必要なのは最後の<code>CREATE FOREIGN TABLE</code>のみです。</p>
<pre><code>CREATE FOREIGN TABLE flogdata (
    ts        timestamp,
    sensor_id int,
    signal1   smallint,
    signal2   smallint,
    signal3   smallint,
    signal4   smallint,
) SERVER arrow_fdw
  OPTIONS (file '/path/to/logdata.arrow');
</code></pre>
<p><code>CREATE FOREIGN TABLE</code>構文で指定した列のデータ型は、マップするArrow形式ファイルのスキーマ定義と厳密に一致している必要があります。</p>
<p>これ以外にも、Arrow_Fdwは<code>IMPORT FOREIGN SCHEMA</code>構文を用いた便利な方法に対応しています。これは、Arrow形式ファイルの持つスキーマ情報を利用して、自動的にテーブル定義を生成するというものです。 以下のように、外部テーブル名とインポート先のスキーマ、およびOPTION句でArrow形式ファイルのパスを指定します。 Arrowファイルのスキーマ定義には、列ごとのデータ型と列名（オプション）が含まれており、これを用いて外部テーブルの定義を行います。</p>
<pre><code>IMPORT FOREIGN SCHEMA flogdata
  FROM SERVER arrow_fdw
  INTO public
OPTIONS (file '/path/to/logdata.arrow');
</code></pre>
<h3 id="_4">外部テーブルオプション</h3>
<p>Arrow_Fdwは以下のオプションに対応しています。</p>
<h4 id="_5">外部テーブルに対するオプション</h4>
<dl>
<dt><code>file=PATHNAME</code></dt>
<dd>外部テーブルにマップするArrowファイルを1個指定します。</dd>
<dt><code>files=PATHNAME1[,PATHNAME2...]</code></dt>
<dd>外部テーブルにマップするArrowファイルをカンマ(,）区切りで複数指定します。</dd>
<dt><code>dir=DIRNAME</code></dt>
<dd>指定したディレクトリに格納されている全てのファイルを外部テーブルにマップします。</dd>
<dt><code>suffix=SUFFIX</code></dt>
<dd><code>dir</code>オプションの指定時、例えば<code>.arrow</code>など、特定の接尾句を持つファイルだけをマップします。</dd>
<dt><code>parallel_workers=N_WORKERS</code></dt>
<dd>この外部テーブルの並列スキャンに使用する並列ワーカープロセスの数を指定します。一般的なテーブルにおける<code>parallel_workers</code>ストレージパラメータと同等の意味を持ちます。</dd>
<dt><code>pattern=PATTERN</code></dt>
<dd><code>file</code>、<code>files</code>、または<code>dir</code>オプションで指定されたファイルのうち、ワイルドカードを含む<code>PATTERN</code>にマッチしたものだけを外部テーブルにマップします。</dd>
<dd>ワイルドカードには以下のものを利用することができます。</dd>
<dd>
<ul>
<li><code>?</code> ... 任意の1文字にマッチする。</li>
</ul>
</dd>
<dd>
<ul>
<li><code>*</code> ... 任意の0文字以上の文字列にマッチする。</li>
</ul>
</dd>
<dd>
<ul>
<li><code>${KEY}</code> ... 任意の0文字以上の文字列にマッチする。</li>
</ul>
</dd>
<dd>
<ul>
<li><code>@{KEY}</code> ... 任意の0文字以上の数値列にマッチする。</li>
</ul>
</dd>
<dd></dd>
<dd>このオプションには面白い使い方があり、ワイルドカードの<code>${KEY}</code>や<code>@{KEY}</code>でマッチしたファイル名の一部分を、仮想列として参照することができます。詳しくは、'''Arrow_Fdwの仮想列'''を参照してください。</dd>
</dl>
<h4 id="_6">カラムに対するオプション</h4>
<dl>
<dt><code>field=FIELD</code></dt>
<dd>そのカラムにマップするArrowファイルのフィールド名を指定します。</dd>
<dd>デフォルトでは、この外部テーブルの列名と同じフィールドのうち、最も最初に出現したフィールドをマップします。</dd>
<dt><code>virtual=KEY</code></dt>
<dd>そのカラムが仮想列である事を指定します。<code>KEY</code>はテーブルオプションの<code>pattern</code>オプションで指定されたパターン中のワイルドカードのキー名を指定します。</dd>
<dd>仮想列はファイル名パターンのうち<code>KEY</code>にマッチした部分をクエリで参照することができます。</dd>
<dt><code>virtual_metadata=KEY</code></dt>
<dd>そのカラムが仮想列である事を指定します。<code>KEY</code>はArrowファイルのCustomMetadataフィールドに埋め込まれたKEY-VALUEペアを指定します。指定したKEY-VALUEペアが見つからない場合、このカラムはNULL値を返します。</dd>
<dd>ArrowファイルのCustomMetadataには、スキーマ（PostgreSQLのテーブルに相当）に埋め込まれるものと、フィールド（PostgreSQLの列に相当）に埋め込まれるものの二種類があります。</dd>
<dd>例えば、<code>lo_orderdate.max_values</code>のように、KEY値の前に<code>.</code>文字で区切られたフィールド名を記述する事で、フィールドに埋め込まれたCustomMetadataを参照する事が出来ます。フィールド名がない場合は、スキーマに埋め込まれたKEY-VALUEペアであるとして扱われます。</dd>
<dt><code>virtual_metadata_split=KEY</code></dt>
<dd>そのカラムが仮想列である事を指定します。<code>KEY</code>はArrowファイルのCustomMetadataフィールドに埋め込まれたKEY-VALUEペアを指定します。指定したKEY-VALUEペアが見つからない場合、このカラムはNULL値を返します。</dd>
<dd><code>virtual_metadata</code>との違いは、CustomMetadataフィールドの値をデリミタ（<code>,</code>）で区切り、それを個々のRecord Batchに先頭から順に当てはめて行くことです。例えば、指定したCustomMetadataの値が<code>Tokyo,Osaka,Kyoto,Yokohama</code>であった場合、RecordBatch-0から読み出した行では<code>'Tokyo'</code>が、RecordBatch-1から読み出した行では<code>'Osaka'</code>が、RecordBatch-2から読み出した行では<code>'Osaka'</code>がこの仮想列の値として表示されます。</dd>
</dl>
<h3 id="_7">データ型の対応</h3>
<p>Arrow形式のデータ型と、PostgreSQLのデータ型は以下のように対応しています。</p>
<dl>
<dt><code>Int</code></dt>
<dd><code>bitWidth</code>属性の値に応じて、それぞれ<code>int1</code>、<code>int2</code>、<code>int4</code>、<code>int8</code>のいずれかに対応。</dd>
<dd><code>is_signed</code>属性の値は無視されます。</dd>
<dd><code>int1</code>はPG-Stromによる独自拡張</dd>
<dt><code>FloatingPoint</code></dt>
<dd><code>precision</code>属性の値に応じて、それぞれ<code>float2</code>、<code>float4</code>、<code>float8</code>のいずれかに対応。</dd>
<dd><code>float2</code>はPG-Stromによる独自拡張</dd>
<dt><code>Utf8</code>, <code>LargeUtf8</code></dt>
<dd><code>text</code>型に対応</dd>
<dt><code>Binary</code>, <code>LargeBinary</code></dt>
<dd><code>bytea</code>型に対応</dd>
<dt><code>Decimal</code></dt>
<dd><code>numeric</code>型に対応</dd>
<dt><code>Date</code></dt>
<dd><code>date</code>型に対応。<code>unit=Day</code>相当となるように補正される。</dd>
<dt><code>Time</code></dt>
<dd><code>time</code>型に対応。<code>unit=MicroSecond</code>相当になるように補正される。</dd>
<dt><code>Timestamp</code></dt>
<dd><code>timestamp</code>型に対応。<code>unit=MicroSecond</code>相当になるように補正される。</dd>
<dt><code>Interval</code></dt>
<dd><code>interval</code>型に対応</dd>
<dt><code>List</code>, <code>LargeList</code></dt>
<dd>要素型の1次元配列型として表現される。</dd>
<dt><code>Struct</code></dt>
<dd>複合型として表現される。対応する複合型は予め定義されていなければならない。</dd>
<dt><code>FixedSizeBinary</code></dt>
<dd><code>byteWidth</code>属性の値に応じて <code>char(n)</code> として表現される。</dd>
<dd>メタデータ <code>pg_type=TYPENAME</code> が指定されている場合、該当するデータ型を割り当てる場合がある。現時点では、<code>inet</code>および<code>macaddr</code>型。</dd>
<dt><code>Union</code>、<code>Map</code>、<code>Duration</code></dt>
<dd>現時点ではPostgreSQLデータ型への対応はなし。</dd>
</dl>
<h3 id="explain">EXPLAIN出力の読み方</h3>
<p><code>EXPLAIN</code>コマンドを用いて、Arrow形式ファイルの読み出しに関する情報を出力する事ができます。</p>
<p>以下の例は、約503GBの大きさを持つArrow形式ファイルをマップしたf_lineorder外部テーブルを含むクエリ実行計画の出力です。</p>
<pre><code>=# EXPLAIN
    SELECT sum(lo_extendedprice*lo_discount) as revenue
      FROM f_lineorder,date1
     WHERE lo_orderdate = d_datekey
       AND d_year = 1993
       AND lo_discount between 1 and 3
       AND lo_quantity &lt; 25;
                                        QUERY PLAN
--------------------------------------------------------------------------------
 Aggregate  (cost=14535261.08..14535261.09 rows=1 width=8)
   -&gt;  Custom Scan (GpuPreAgg) on f_lineorder  (cost=14535261.06..14535261.07 rows=1 width=32)
         GPU Projection: pgstrom.psum(((f_lineorder.lo_extendedprice * f_lineorder.lo_discount))::bigint)
         GPU Scan Quals: ((f_lineorder.lo_discount &gt;= 1) AND (f_lineorder.lo_discount &lt;= 3) AND (f_lineorder.lo_quantity &lt; 25)) [rows: 5999990000 -&gt; 9999983]
         GPU Join Quals [1]: (f_lineorder.lo_orderdate = date1.d_datekey) ... [nrows: 9999983 -&gt; 1428010]
         GPU Outer Hash [1]: f_lineorder.lo_orderdate
         GPU Inner Hash [1]: date1.d_datekey
         referenced: lo_orderdate, lo_quantity, lo_extendedprice, lo_discount
         file0: /opt/nvme/f_lineorder_s999.arrow (read: 89.41GB, size: 502.92GB)
         GPU-Direct SQL: enabled (GPU-0)
         -&gt;  Seq Scan on date1  (cost=0.00..78.95 rows=365 width=4)
               Filter: (d_year = 1993)
(12 rows)
</code></pre>
<p>これを見るとCustom Scan (GpuPreAgg)が<code>f_lineorder</code>外部テーブルをスキャンしている事がわかります。 <code>file0</code>には外部テーブルの背後にあるファイル名<code>/opt/nvme/f_lineorder_s999.arrow</code>とそのサイズが表示されます。複数のファイルがマップされている場合には、<code>file1</code>、<code>file2</code>、... と各ファイル毎に表示されます。 <code>referenced</code>には実際に参照されている列の一覧が列挙されており、このクエリにおいては<code>lo_orderdate</code>、<code>lo_quantity</code>、<code>lo_extendedprice</code>および<code>lo_discount</code>列が参照されている事がわかります。</p>
<p>また、<code>GPU-Direct SQL: enabled (GPU-0)</code>の表示がある事から、<code>f_lineorder</code>のスキャンにはGPU-Direct SQL機構が用いられることが分かります。</p>
<p>VERBOSEオプションを付与する事で、より詳細な情報が出力されます。</p>
<pre><code>=# EXPLAIN VERBOSE
    SELECT sum(lo_extendedprice*lo_discount) as revenue
      FROM f_lineorder,date1
     WHERE lo_orderdate = d_datekey
       AND d_year = 1993
       AND lo_discount between 1 and 3
       AND lo_quantity &lt; 25;
                                        QUERY PLAN
--------------------------------------------------------------------------------
 Aggregate  (cost=14535261.08..14535261.09 rows=1 width=8)
   Output: pgstrom.sum_int((pgstrom.psum(((f_lineorder.lo_extendedprice * f_lineorder.lo_discount))::bigint)))
   -&gt;  Custom Scan (GpuPreAgg) on public.f_lineorder  (cost=14535261.06..14535261.07 rows=1 width=32)
         Output: (pgstrom.psum(((f_lineorder.lo_extendedprice * f_lineorder.lo_discount))::bigint))
         GPU Projection: pgstrom.psum(((f_lineorder.lo_extendedprice * f_lineorder.lo_discount))::bigint)
         GPU Scan Quals: ((f_lineorder.lo_discount &gt;= 1) AND (f_lineorder.lo_discount &lt;= 3) AND (f_lineorder.lo_quantity &lt; 25)) [rows: 5999990000 -&gt; 9999983]
         GPU Join Quals [1]: (f_lineorder.lo_orderdate = date1.d_datekey) ... [nrows: 9999983 -&gt; 1428010]
         GPU Outer Hash [1]: f_lineorder.lo_orderdate
         GPU Inner Hash [1]: date1.d_datekey
         referenced: lo_orderdate, lo_quantity, lo_extendedprice, lo_discount
         file0: /opt/nvme/f_lineorder_s999.arrow (read: 89.41GB, size: 502.92GB)
           lo_orderdate: 22.35GB
           lo_quantity: 22.35GB
           lo_extendedprice: 22.35GB
           lo_discount: 22.35GB
         GPU-Direct SQL: enabled (GPU-0)
         KVars-Slot: &lt;slot=0, type='int4', expr='f_lineorder.lo_discount'&gt;, &lt;slot=1, type='int4', expr='f_lineorder.lo_quantity'&gt;, &lt;slot=2, type='int8', expr='(f_lineorder.lo_extendedprice * f_lineorder.lo_discount)'&gt;, &lt;slot=3, type='int4', expr='f_lineorder.lo_extendedprice'&gt;, &lt;slot=4, type='int4', expr='f_lineorder.lo_orderdate'&gt;, &lt;slot=5, type='int4', expr='date1.d_datekey'&gt;
         KVecs-Buffer: nbytes: 51200, ndims: 3, items=[kvec0=&lt;0x0000-27ff, type='int4', expr='lo_discount'&gt;, kvec1=&lt;0x2800-4fff, type='int4', expr='lo_quantity'&gt;, kvec2=&lt;0x5000-77ff, type='int4', expr='lo_extendedprice'&gt;, kvec3=&lt;0x7800-9fff, type='int4', expr='lo_orderdate'&gt;, kvec4=&lt;0xa000-c7ff, type='int4', expr='d_datekey'&gt;]
         LoadVars OpCode: {Packed items[0]={LoadVars(depth=0): kvars=[&lt;slot=4, type='int4' resno=6(lo_orderdate)&gt;, &lt;slot=1, type='int4' resno=9(lo_quantity)&gt;, &lt;slot=3, type='int4' resno=10(lo_extendedprice)&gt;, &lt;slot=0, type='int4' resno=12(lo_discount)&gt;]}, items[1]={LoadVars(depth=1): kvars=[&lt;slot=5, type='int4' resno=1(d_datekey)&gt;]}}
         MoveVars OpCode: {Packed items[0]={MoveVars(depth=0): items=[&lt;slot=0, offset=0x0000-27ff, type='int4', expr='lo_discount'&gt;, &lt;slot=3, offset=0x5000-77ff, type='int4', expr='lo_extendedprice'&gt;, &lt;slot=4, offset=0x7800-9fff, type='int4', expr='lo_orderdate'&gt;]}}, items[1]={MoveVars(depth=1): items=[&lt;offset=0x0000-27ff, type='int4', expr='lo_discount'&gt;, &lt;offset=0x5000-77ff, type='int4', expr='lo_extendedprice'&gt;]}}}
         Scan Quals OpCode: {Bool::AND args=[{Func(bool)::int4ge args=[{Var(int4): slot=0, expr='lo_discount'}, {Const(int4): value='1'}]}, {Func(bool)::int4le args=[{Var(int4): slot=0, expr='lo_discount'}, {Const(int4): value='3'}]}, {Func(bool)::int4lt args=[{Var(int4): slot=1, expr='lo_quantity'}, {Const(int4): value='25'}]}]}
         Join Quals OpCode: {Packed items[1]={JoinQuals:  {Func(bool)::int4eq args=[{Var(int4): kvec=0x7800-a000, expr='lo_orderdate'}, {Var(int4): slot=5, expr='d_datekey'}]}}}
         Join HashValue OpCode: {Packed items[1]={HashValue arg={Var(int4): kvec=0x7800-a000, expr='lo_orderdate'}}}
         Partial Aggregation OpCode: {AggFuncs &lt;psum::int[slot=2, expr='(lo_extendedprice * lo_discount)']&gt; arg={SaveExpr: &lt;slot=2, type='int8'&gt; arg={Func(int8)::int8 arg={Func(int4)::int4mul args=[{Var(int4): kvec=0x5000-7800, expr='lo_extendedprice'}, {Var(int4): kvec=0x0000-2800, expr='lo_discount'}]}}}}
         Partial Function BufSz: 16
         -&gt;  Seq Scan on public.date1  (cost=0.00..78.95 rows=365 width=4)
               Output: date1.d_datekey
               Filter: (date1.d_year = 1993)
(28 rows)
</code></pre>
<p>被参照列をロードする際に読み出すべき列データの大きさを、列ごとに表示しています。 <code>lo_orderdate</code>、<code>lo_quantity</code>、<code>lo_extendedprice</code>および<code>lo_discount</code>列のロードには合計で89.41GBの読み出しが必要で、これはファイルサイズ502.93GBの17.8%に相当します。</p>
<h2 id="arrow_fdw">Arrow_Fdwの仮想列</h2>
<p>Arrow_Fdwはスキーマ構造に互換性のある複数のApache Arrowを一個の外部テーブルにマッピングすることができます。例えば、外部テーブルオプションに<code>dir '/opt/arrow/mydata'</code>を指定すると、そのディレクトリ配下に存在する全てのファイルをマッピングするようになります。</p>
<p>トランザクショナルなデータベースの内容をApache Arrowファイルに変換するときに年月や特定のカテゴリ毎に分けてファイル化し、それらを反映したファイル名を付けて保存する事はしばしば行われています。</p>
<p>例えば、以下の例をご覧ください。トランザクショナルなテーブルである<code>lineorder</code>を<code>lo_orderdate</code>の年単位、および<code>lo_shipmode</code>のカテゴリ毎にArrowファイルへと変換しています。</p>
<pre><code>$ for s in RAIL AIR TRUCK SHIP FOB MAIL;
  do
    for y in 1993 1994 1995 1996 1997;
    do
      pg2arrow -d ssbm -c &quot;SELECT * FROM lineorder_small \
                            WHERE lo_orderdate between ${y}0101 and ${y}1231 \
                              AND lo_shipmode = '${s}'&quot; \
               -o /opt/arrow/mydata/f_lineorder_${y}_${s}.arrow
    done
  done
$ ls /opt/arrow/mydata/
f_lineorder_1993_AIR.arrow    f_lineorder_1995_RAIL.arrow
f_lineorder_1993_FOB.arrow    f_lineorder_1995_SHIP.arrow
f_lineorder_1993_MAIL.arrow   f_lineorder_1995_TRUCK.arrow
f_lineorder_1993_RAIL.arrow   f_lineorder_1996_AIR.arrow
f_lineorder_1993_SHIP.arrow   f_lineorder_1996_FOB.arrow
f_lineorder_1993_TRUCK.arrow  f_lineorder_1996_MAIL.arrow
f_lineorder_1994_AIR.arrow    f_lineorder_1996_RAIL.arrow
f_lineorder_1994_FOB.arrow    f_lineorder_1996_SHIP.arrow
f_lineorder_1994_MAIL.arrow   f_lineorder_1996_TRUCK.arrow
f_lineorder_1994_RAIL.arrow   f_lineorder_1997_AIR.arrow
f_lineorder_1994_SHIP.arrow   f_lineorder_1997_FOB.arrow
f_lineorder_1994_TRUCK.arrow  f_lineorder_1997_MAIL.arrow
f_lineorder_1995_AIR.arrow    f_lineorder_1997_RAIL.arrow
f_lineorder_1995_FOB.arrow    f_lineorder_1997_SHIP.arrow
f_lineorder_1995_MAIL.arrow   f_lineorder_1997_TRUCK.arrow
</code></pre>
<p>これらのApache Arrowファイルは全て同じスキーマ構造を持っており、<code>dir</code>オプションを用いて1個の外部テーブルにマッピングできます。
また、データの生成時に絞り込みを行っているため、ファイル名に1995を含むファイルには<code>lo_orderdate</code>が19950101～19951231の範囲のレコードしか含まれておらず、ファイル名に<code>RAIL</code>を含むファイルには<code>lo_shipmode</code>が<code>RAIL</code>のレコードしか含まれていません。</p>
<p>つまり、これら複数のArrowファイルをマップしたArrow_Fdw外部テーブルを定義したとしても、ファイル名に1995を含むファイルからデータを読み出している時には、<code>lo_orderdate</code>の値が19950101～19951231の範囲であることが事前に分かっており、それを利用した最適化が可能です。</p>
<p>Arrow_Fdwでは、外部テーブルオプション<code>pattern</code>を使用する事でファイル名の一部を列として参照する事ができます。これを仮想列と呼び、以下のように設定します。</p>
<pre><code>=# IMPORT FOREIGN SCHEMA f_lineorder
     FROM SERVER arrow_fdw INTO public
  OPTIONS (dir '/opt/arrow/mydata', pattern 'f_lineorder_@{year}_${shipping}.arrow');
IMPORT FOREIGN SCHEMA

=# \d f_lineorder
                             Foreign table &quot;public.f_lineorder&quot;
       Column       |     Type      | Collation | Nullable | Default |     FDW options
--------------------+---------------+-----------+----------+---------+----------------------
 lo_orderkey        | numeric       |           |          |         |
 lo_linenumber      | integer       |           |          |         |
 lo_custkey         | numeric       |           |          |         |
 lo_partkey         | integer       |           |          |         |
 lo_suppkey         | numeric       |           |          |         |
 lo_orderdate       | integer       |           |          |         |
 lo_orderpriority   | character(15) |           |          |         |
 lo_shippriority    | character(1)  |           |          |         |
 lo_quantity        | numeric       |           |          |         |
 lo_extendedprice   | numeric       |           |          |         |
 lo_ordertotalprice | numeric       |           |          |         |
 lo_discount        | numeric       |           |          |         |
 lo_revenue         | numeric       |           |          |         |
 lo_supplycost      | numeric       |           |          |         |
 lo_tax             | numeric       |           |          |         |
 lo_commit_date     | character(8)  |           |          |         |
 lo_shipmode        | character(10) |           |          |         |
 year               | bigint        |           |          |         | (virtual 'year')
 shipping           | text          |           |          |         | (virtual 'shipping')
Server: arrow_fdw
FDW options: (dir '/opt/arrow/mydata', pattern 'f_lineorder_@{year}_${shipping}.arrow')
</code></pre>
<p>この外部テーブルオプション<code>pattern</code>には2つのワイルドカードが含まれています。
0文字以上の数字列にマッチする<code>@{year}</code>と、0文字以上の文字列にマッチする<code>${shipping}</code>です。
ファイル名のうち、この部分にマッチしたパターンは、それぞれ列オプションの<code>virtual</code>で指定した部分で参照することができます。
この場合、<code>IMPORT FOREIGN SCHEMA</code>が自動的に列定義を加え、Arrowファイル自体に含まれているフィールドに加えて、ワイルドカード<code>@{year}</code>を参照する仮想列<code>year</code>（数値列であるため<code>bigint</code>データ型）と、<code>${shipping}</code>を参照する仮想列<code>shipping</code>を追加しています。</p>
<p>これらの仮想列に対応するフィールドはArrowファイルには存在しませんが、例えば、ファイル<code>f_lineorder_1994_AIR.arrow</code>から読みだした行を処理するときには<code>year</code>列の値は1994に、<code>shipping</code>列の値は'AIR'になるわけです。</p>
<pre><code>=# SELECT lo_orderkey, lo_orderdate, lo_shipmode, year, shipping
     FROM f_lineorder
    WHERE year = 1995 AND shipping = 'AIR'
    LIMIT 10;
 lo_orderkey | lo_orderdate | lo_shipmode | year | shipping
-------------+--------------+-------------+------+----------
      637892 |     19950512 | AIR         | 1995 | AIR
      638243 |     19950930 | AIR         | 1995 | AIR
      638273 |     19951214 | AIR         | 1995 | AIR
      637443 |     19950805 | AIR         | 1995 | AIR
      637444 |     19950803 | AIR         | 1995 | AIR
      637510 |     19950831 | AIR         | 1995 | AIR
      637504 |     19950726 | AIR         | 1995 | AIR
      637863 |     19950802 | AIR         | 1995 | AIR
      637892 |     19950512 | AIR         | 1995 | AIR
      637987 |     19950211 | AIR         | 1995 | AIR
(10 rows)
</code></pre>
<p>これは言い換えれば、Arrow_Fdw外部テーブルがマップしたArrowファイルを実際に読む前に、仮想列がどのような値になっているのかを知る事ができるという事です。この特徴を使えば、あるArrowファイルの読み出しの前に、検索条件から1件もマッチしない事が明らかである場合には、ファイルの読み出し自体をスキップする事が可能であるという事になります。</p>
<p>以下のクエリとその<code>EXPLAIN ANALYZE</code>出力をご覧ください。</p>
<p>この集計クエリは<code>f_lineorder</code>外部テーブルを読み出し、いくつかの条件で絞り込んだ後、<code>lo_extendedprice * lo_discount</code>の合計値を集計します。
その時、<code>WHERE year = 1994</code>という条件句が付加されています。これは実質的には<code>WHERE lo_orderdate BETWEEN 19940101 AND 19942131</code>と同じですが、<code>year</code>は仮想列であるため、Arrowファイルを読み出す前にマッチする行が存在するかどうかを判定する事ができます。</p>
<p>実際、<code>Stats-Hint:</code>行を見ると、<code>(year = 1994)</code>という条件によって12個のRecord-Batchがロードされたものの、48個のRecord-Batchはスキップされています。これは単純ですがI/Oの負荷を軽減する手段として極めて有効です。</p>
<pre><code>=# EXPLAIN ANALYZE
   SELECT sum(lo_extendedprice*lo_discount) as revenue
     FROM f_lineorder
    WHERE year = 1994
      AND lo_discount between 1 and 3
      AND lo_quantity &lt; 25;
                                               QUERY PLAN
--------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=421987.07..421987.08 rows=1 width=32) (actual time=82.914..82.915 rows=1 loops=1)
   -&gt;  Custom Scan (GpuPreAgg) on f_lineorder  (cost=421987.05..421987.06 rows=1 width=32)      \
                                               (actual time=82.901..82.903 rows=2 loops=1)
         GPU Projection: pgstrom.psum(((lo_extendedprice * lo_discount))::double precision)
         GPU Scan Quals: ((year = 1994) AND (lo_discount &lt;= '3'::numeric) AND                   \
                          (lo_quantity &lt; '25'::numeric) AND                                     \
                          (lo_discount &gt;= '1'::numeric)) [plan: 65062080 -&gt; 542, exec: 13001908 -&gt; 1701726]
         referenced: lo_quantity, lo_extendedprice, lo_discount, year
         Stats-Hint: (year = 1994)  [loaded: 12, skipped: 48]
         file0: /opt/arrow/mydata/f_lineorder_1996_MAIL.arrow (read: 99.53MB, size: 427.16MB)
         file1: /opt/arrow/mydata/f_lineorder_1996_SHIP.arrow (read: 99.52MB, size: 427.13MB)
         file2: /opt/arrow/mydata/f_lineorder_1994_FOB.arrow (read: 99.18MB, size: 425.67MB)
              :                :                                       :             :
         file27: /opt/arrow/mydata/f_lineorder_1997_MAIL.arrow (read: 99.23MB, size: 425.87MB)
         file28: /opt/arrow/mydata/f_lineorder_1995_MAIL.arrow (read: 99.16MB, size: 425.58MB)
         file29: /opt/arrow/mydata/f_lineorder_1993_TRUCK.arrow (read: 99.24MB, size: 425.91MB)
         GPU-Direct SQL: enabled (N=2,GPU0,1; direct=76195, ntuples=13001908)
 Planning Time: 2.402 ms
 Execution Time: 83.857 ms
(39 rows)
</code></pre>
<h2 id="arrow">Arrowファイルの作成方法</h2>
<p>本節では、既にPostgreSQLデータベースに格納されているデータをApache Arrow形式に変換する方法を説明します。</p>
<h3 id="pyarrowpandas">PyArrow+Pandas</h3>
<p>Arrow開発者コミュニティが開発を行っている PyArrow モジュールとPandasデータフレームの組合せを用いて、PostgreSQLデータベースの内容をArrow形式ファイルへと書き出す事ができます。</p>
<p>以下の例は、テーブルt0に格納されたデータを全て読込み、ファイル/tmp/t0.arrowへと書き出すというものです。</p>
<pre><code>import pyarrow as pa
import pandas as pd

X = pd.read_sql(sql=&quot;SELECT * FROM t0&quot;, con=&quot;postgresql://localhost/postgres&quot;)
Y = pa.Table.from_pandas(X)
f = pa.RecordBatchFileWriter('/tmp/t0.arrow', Y.schema)
f.write_table(Y,1000000)      # RecordBatch for each million rows
f.close()
</code></pre>
<p>ただし上記の方法は、SQLを介してPostgreSQLから読み出したデータベースの内容を一度メモリに保持するため、大量の行を一度に変換する場合には注意が必要です。</p>
<h3 id="pg2arrow">Pg2Arrow</h3>
<p>一方、PG-Strom Development Teamが開発を行っている <code>pg2arrow</code> コマンドを使用して、PostgreSQLデータベースの内容をArrow形式ファイルへと書き出す事ができます。 このツールは比較的大量のデータをNVME-SSDなどストレージに書き出す事を念頭に設計されており、PostgreSQLデータベースから<code>-s|--segment-size</code>オプションで指定したサイズのデータを読み出すたびに、Arrow形式のレコードバッチ（Record Batch）としてファイルに書き出します。そのため、メモリ消費量は比較的リーズナブルな値となります。</p>
<p><code>pg2arrow</code>コマンドはPG-Stromに同梱されており、PostgreSQL関連コマンドのインストール先ディレクトリに格納されます。</p>
<pre><code>$ pg2arrow --help
Usage:
  pg2arrow [OPTION] [database] [username]

General options:
  -d, --dbname=DBNAME   Database name to connect to
  -c, --command=COMMAND SQL command to run
  -t, --table=TABLENAME Equivalent to '-c SELECT * FROM TABLENAME'
      (-c and -t are exclusive, either of them must be given)
      --inner-join=SUB_COMMAND
      --outer-join=SUB_COMMAND
  -o, --output=FILENAME result file in Apache Arrow format
      --append=FILENAME result Apache Arrow file to be appended
      (--output and --append are exclusive. If neither of them
       are given, it creates a temporary file.)
  -S, --stat[=COLUMNS] embeds min/max statistics for each record batch
                       COLUMNS is a comma-separated list of the target
                       columns if partially enabled.

Arrow format options:
  -s, --segment-size=SIZE size of record batch for each

Connection options:
  -h, --host=HOSTNAME  database server host
  -p, --port=PORT      database server port
  -u, --user=USERNAME  database user name
  -w, --no-password    never prompt for password
  -W, --password       force password prompt

Other options:
      --dump=FILENAME  dump information of arrow file
      --progress       shows progress of the job
      --set=NAME:VALUE config option to set before SQL execution
      --help           shows this message

Report bugs to &lt;pgstrom@heterodbcom&gt;.
</code></pre>
<p>PostgreSQLへの接続パラメータはpsqlやpg_dumpと同様に、<code>-h</code>や<code>-U</code>などのオプションで指定します。 基本的なコマンドの使用方法は、<code>-c|--command</code>オプションで指定したSQLをPostgreSQL上で実行し、その結果を<code>-o|--output</code>で指定したファイルへArrow形式で書き出します。</p>
<p><code>-o|--output</code>オプションの代わりに<code>--append</code>オプションを使用する事ができ、これは既存のApache Arrowファイルへの追記を意味します。この場合、追記されるApache Arrowファイルは指定したSQLの実行結果と完全に一致するスキーマ構造を持たねばなりません。</p>
<p>以下の例は、テーブル<code>t0</code>に格納されたデータを全て読込み、ファイル<code>/tmp/t0.arrow</code>へと書き出すというものです。</p>
<pre><code>$ pg2arrow -U kaigai -d postgres -c &quot;SELECT * FROM t0&quot; -o /tmp/t0.arrow
</code></pre>
<p>開発者向けオプションですが、<code>--dump &lt;filename&gt;</code>でArrow形式ファイルのスキーマ定義やレコードバッチの位置とサイズを可読な形式で出力する事もできます。</p>
<p><code>--progress</code>オプションを指定すると、処理の途中経過を表示する事が可能です。これは巨大なテーブルをApache Arrow形式に変換する際に有用です。</p>
<h2 id="_8">先進的な使い方</h2>
<h3 id="ssdtogpusql">SSDtoGPUダイレクトSQL</h3>
<p>Arrow_Fdw外部テーブルにマップされた全てのArrow形式ファイルが以下の条件を満たす場合には、列データの読み出しにSSD-to-GPUダイレクトSQLを使用する事ができます。</p>
<ul>
<li>Arrow形式ファイルがNVME-SSD区画上に置かれている。</li>
<li>NVME-SSD区画はExt4ファイルシステムで構築されている。</li>
<li>Arrow形式ファイルの総計が<code>pg_strom.nvme_strom_threshold</code>設定を上回っている。</li>
</ul>
<h3 id="_9">パーティション設定</h3>
<p>Arrow_Fdw外部テーブルを、パーティションの一部として利用する事ができます。 通常のPostgreSQLテーブルと混在する事も可能ですが、Arrow_Fdw外部テーブルは書き込みに対応していない事に注意してください。 また、マップされたArrow形式ファイルに含まれるデータは、パーティションの境界条件と矛盾しないように設定してください。これはデータベース管理者の責任です。</p>
<p><img alt="Example of partition configuration" src="../img/partition-logdata.png" /></p>
<p>典型的な利用シーンは、長期間にわたり蓄積したログデータの処理です。</p>
<p>トランザクションデータと異なり、一般的にログデータは一度記録されたらその後更新削除されることはありません。 したがって、一定期間が経過したログデータは、読み出し専用ではあるものの集計処理が高速なArrow_Fdw外部テーブルに移し替えることで、集計・解析ワークロードの処理効率を引き上げる事が可能となります。また、ログデータにはほぼ間違いなくタイムスタンプが付与されている事から、月単位、週単位など、一定期間ごとにパーティション子テーブルを追加する事が可能です。</p>
<p>以下の例は、PostgreSQLテーブルとArrow_Fdw外部テーブルを混在させたパーティションテーブルを定義したものです。</p>
<p>書き込みが可能なPostgreSQLテーブルをデフォルトパーティションとして指定しておく事で、一定期間の経過後、DB運用を継続しながら過去のログデータだけをArrow_Fdw外部テーブルへ移す事が可能です。</p>
<pre><code>CREATE TABLE lineorder (
    lo_orderkey numeric,
    lo_linenumber integer,
    lo_custkey numeric,
    lo_partkey integer,
    lo_suppkey numeric,
    lo_orderdate integer,
    lo_orderpriority character(15),
    lo_shippriority character(1),
    lo_quantity numeric,
    lo_extendedprice numeric,
    lo_ordertotalprice numeric,
    lo_discount numeric,
    lo_revenue numeric,
    lo_supplycost numeric,
    lo_tax numeric,
    lo_commit_date character(8),
    lo_shipmode character(10)
) PARTITION BY RANGE (lo_orderdate);

CREATE TABLE lineorder__now PARTITION OF lineorder default;

CREATE FOREIGN TABLE lineorder__1993 PARTITION OF lineorder
   FOR VALUES FROM (19930101) TO (19940101)
SERVER arrow_fdw OPTIONS (file '/opt/tmp/lineorder_1993.arrow');

CREATE FOREIGN TABLE lineorder__1994 PARTITION OF lineorder
   FOR VALUES FROM (19940101) TO (19950101)
SERVER arrow_fdw OPTIONS (file '/opt/tmp/lineorder_1994.arrow');

CREATE FOREIGN TABLE lineorder__1995 PARTITION OF lineorder
   FOR VALUES FROM (19950101) TO (19960101)
SERVER arrow_fdw OPTIONS (file '/opt/tmp/lineorder_1995.arrow');

CREATE FOREIGN TABLE lineorder__1996 PARTITION OF lineorder
   FOR VALUES FROM (19960101) TO (19970101)
SERVER arrow_fdw OPTIONS (file '/opt/tmp/lineorder_1996.arrow');
</code></pre>
<p>このテーブルに対する問い合わせの実行計画は以下のようになります。 検索条件<code>lo_orderdate between 19950701 and 19960630</code>がパーティションの境界条件を含んでいる事から、子テーブル<code>lineorder__1993</code>と<code>lineorder__1994</code>は検索対象から排除され、他のテーブルだけを読み出すよう実行計画が作られています。</p>
<pre><code>=# EXPLAIN
    SELECT sum(lo_extendedprice*lo_discount) as revenue
      FROM lineorder,date1
     WHERE lo_orderdate = d_datekey
       AND lo_orderdate between 19950701 and 19960630
       AND lo_discount between 1 and 3
       ABD lo_quantity &lt; 25;

                                 QUERY PLAN
--------------------------------------------------------------------------------
 Aggregate  (cost=172088.90..172088.91 rows=1 width=32)
   -&gt;  Hash Join  (cost=10548.86..172088.51 rows=77 width=64)
         Hash Cond: (lineorder__1995.lo_orderdate = date1.d_datekey)
         -&gt;  Append  (cost=10444.35..171983.80 rows=77 width=67)
               -&gt;  Custom Scan (GpuScan) on lineorder__1995  (cost=10444.35..33671.87 rows=38 width=68)
                     GPU Filter: ((lo_orderdate &gt;= 19950701) AND (lo_orderdate &lt;= 19960630) AND
                                  (lo_discount &gt;= '1'::numeric) AND (lo_discount &lt;= '3'::numeric) AND
                                  (lo_quantity &lt; '25'::numeric))
                     referenced: lo_orderdate, lo_quantity, lo_extendedprice, lo_discount
                     files0: /opt/tmp/lineorder_1995.arrow (size: 892.57MB)
               -&gt;  Custom Scan (GpuScan) on lineorder__1996  (cost=10444.62..33849.21 rows=38 width=68)
                     GPU Filter: ((lo_orderdate &gt;= 19950701) AND (lo_orderdate &lt;= 19960630) AND
                                  (lo_discount &gt;= '1'::numeric) AND (lo_discount &lt;= '3'::numeric) AND
                                  (lo_quantity &lt; '25'::numeric))
                     referenced: lo_orderdate, lo_quantity, lo_extendedprice, lo_discount
                     files0: /opt/tmp/lineorder_1996.arrow (size: 897.87MB)
               -&gt;  Custom Scan (GpuScan) on lineorder__now  (cost=11561.33..104462.33 rows=1 width=18)
                     GPU Filter: ((lo_orderdate &gt;= 19950701) AND (lo_orderdate &lt;= 19960630) AND
                                  (lo_discount &gt;= '1'::numeric) AND (lo_discount &lt;= '3'::numeric) AND
                                  (lo_quantity &lt; '25'::numeric))
         -&gt;  Hash  (cost=72.56..72.56 rows=2556 width=4)
               -&gt;  Seq Scan on date1  (cost=0.00..72.56 rows=2556 width=4)
(16 rows)

</code></pre>
<p>この後、<code>lineorder__now</code>テーブルから1997年のデータを抜き出し、これをArrow_Fdw外部テーブル側に移すには以下の操作を行います</p>
<pre><code>$ pg2arrow -d sample  -o /opt/tmp/lineorder_1997.arrow \
           -c &quot;SELECT * FROM lineorder WHERE lo_orderdate between 19970101 and 19971231&quot;
</code></pre>
<p><code>pg2arrow</code>コマンドにより、<code>lineorder</code>テーブルから1997年のデータだけを抜き出して、新しいArrow形式ファイルへ書き出します。</p>
<pre><code>BEGIN;
--
-- remove rows in 1997 from the read-writable table
--
DELETE FROM lineorder WHERE lo_orderdate BETWEEN 19970101 AND 19971231;
--
-- define a new partition leaf which maps log-data in 1997
--
CREATE FOREIGN TABLE lineorder__1997 PARTITION OF lineorder
   FOR VALUES FROM (19970101) TO (19980101)
SERVER arrow_fdw OPTIONS (file '/opt/tmp/lineorder_1997.arrow');

COMMIT;
</code></pre>
<p>この操作により、PostgreSQLテーブルである<code>lineorder__now</code>から1997年のデータを削除し、代わりに同一内容のArrow形式ファイル<code>/opt/tmp/lineorder_1997.arrow</code>を外部テーブル<code>lineorder__1997</code>としてマップしました。</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>正確には、4KB～32KBの範囲でビルド時に指定できます&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../ssd2gpu/" class="btn btn-neutral float-left" title="GPUダイレクトSQL"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../gpucache/" class="btn btn-neutral float-right" title="GPUキャッシュ">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../ssd2gpu/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../gpucache/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
